## Info
<a href="https://www.acmicpc.net/problem/10775" rel="nofollow">10775 공항</a>

## ❗ 풀이
비행기 데이터의 숫자가 작을수록 게이트의 제한이 엄격한 것이므로, 도킹이 가능하다면 현재 사용 가능한 게이트 들 중에 게이트 번호가 제한을 넘지 않는 한 가장 큰 곳에 우선적으로 도킹하도록 해야 한다.  
이를 구현하는 가장 간단한 방법은 현재 limit에서 시작하여 순차적으로 Gate를 탐색하고, limit를 1씩 감소시키면서 제일 먼저 찾아지는 비어있는 Gate에 현재 비행기를 도킹시키는 것일 것이나, 문제의 조건에서 시간 제한이 빡빡하게 잡혀 있어 이러한 단순 `O(N^2)` 풀이로는 시간 제한을 만족시키지 못한다.  
  
시간 제한을 해결하기 위한 아이디어는 `gate 개수+1` 만큼(0번째 인덱스는 사용하지 않는다.)의 배열을 미리 선언해 두고, `i`번째  Gate에 접근할 때 마다 `gate[i]++` 해 주어 현재까지 각 게이트별로 접근한 횟수를 저장해 두는 것에서 출발한다. 데이터를 이렇게 유지하면 `gate[i]`는 `i`번째 Gate를 포함하여 그 하위 `gate[i]`개의 Gate는 이미 다른 비행기가 도킹되어 있다는 것을 의미한다. 이를 이용하여 `i`번째 Gate에 도킹이 실패했을 때, `i-1`번째 Gate에 도킹을 시도하는 것이 아닌 `i-gate[i]`번째 Gate로 건너뛰어 시도할 수 있고, 시간을 단축시킬 수 있다.  
  
예를 들어, 초기상태에서 3번 게이트에 접근한다면 게이트가 비어 있으므로 `gate -> [None, 0, 0, 1, ...]`이 되고 해당 비행기는 3번 게이트에 도킹될 것이다.  
이 상태에서 다시 limit이 3인 비행기가 도킹을 시도하면 먼저 3번 게이트에 접근을 하게 된다. 이때 `gate[3]==1` 이므로 다음으로는 `3-1 => 2`번째 Gate에 도킹을 시도하게 되고, 2번 게이트는 비어 있으므로 도킹에 성공한다. 3번 게이트와 2번 게이트에 한 번씩 접근을 시도했으므로 최종적으로는 `gate -> [None, 0, 1, 2, ...]`가 된다.  
또 limit이 3인 다른 비행기가 도킹을 시도한다고 하자. 이 때는 `gate[3]==2`이므로 다음 시도할 Gate는 `1`번 게이트이고, gate배열은 `gate -> [None, 1, 1, 3, ...]`이 된다.  
여기서 한번 더 limit이 3인 비행기가 도킹을 시도하면 `gate[3]==3`이 되는데 `limit-gate[limit] => 0`이 되고, 이 값이 1보다 작아졌다는 의미는 `1`번 게이트부터 `limit`번 게이트에 모두 다른 비행기가 도킹되어 있는 상태라는 뜻이므로 이번 비행기는 도킹될 수 없고, 공항을 폐쇄하게 된다.

[참고]
```
<input>
Gate = 10
Plane = 6
4
4
4
4
6
6
6
---------------------------------------------
<gate 배열 변화>
limit=4, [None, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]
limit=4, [None, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0]
limit=4, [None, 0, 1, 1, 3, 0, 0, 0, 0, 0, 0]
limit=4, [None, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0]
limit=6, [None, 1, 1, 1, 4, 0, 1, 0, 0, 0, 0]
limit=6, [None, 1, 1, 1, 4, 1, 2, 0, 0, 0, 0] --> 이 비행기까지 도킹 가능

ans: 6
```

## ❗ 추가 지식
None

## 🙂 마무리
Union & Find를 깊게 공부할 시간이 여의치 않아서 이번 문제는 어떻게든 반복문으로 해결을 해 보려고 시도했고, 결과적으로는 반복문만을 사용해서 구현하긴 했다.  
하지만 백준 알고리즘 분류에도 '분리 집합'으로 명시되어 있는 만큼, Union & Find 기법을 이용한 풀이도 나중에 시도해 봐야겠다.  
간단히 읽어 보니 Union & Find를 쓸 때도 '경로 압축'이라는 기법을 통해 좀 더 최적화를 노려볼 수 있는 듯.
