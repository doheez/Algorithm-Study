# 🔣 최소 신장 트리 (Minimum Spanning Tree)
## Spanning Tree 

Spanning Tree(신장 트리)는 그래프의 **최소 연결 부분 그래프**이다. <br/>
(최소 연결 : 간선의 수가 가장 적다)<br/>

1. DFS, BFS를 이용하여 그래프에서 신장 트리를 찾을 수 있다.<br/>
2. 하나의 그래프에는 많은 신장트리가 존재할 수 있다.<br/>
3. Spanning Tree는 **모든 정점들이 연결**되어 있어야 하고 **사이클을 포함해서는 안된다**.<br/>
4. Spanning Tree는 그래프에 있는 **n개의 정점을 n-1개의 간선**으로 연결한다.<br/>

## MST (Minimum Spanning Tree)

Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리를 말한다.<br/>

주의할 점은 MST를 구성하기 위한 간선을 선택할 때 단순히 가중치가 작은 간선을 사용한다고 해서
최소 비용이 얻어지는 것이 아니다.<br/>
<br/>
### 구현 방법
**1. Kruskal 알고리즘**<br/>
   greedy method를 이용하여 그래프의 모든 정점을 최소 비용으로 연결하는 방법
- 각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택한다.
- 간선 선택을 기반으로 하는 알고리즘이다.<br/><br/>
#### [과정]<br/>
  1. 그래프의 간선을 가중치의 오름차순으로 정렬한다.<br/>
  2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.<br/>
  3. 선택된 간선을 현재의 MST의 집합에 추가한다.

**2. Prim 알고리즘**<br/>
시작 정점에서 부터 출발하여 신장트리 집합을 단계적으로 확장하는 방법
- 정점 선택을 기반으로 하는 알고리즘이다.<br/><br/>
#### [과정]<br/>
  1. 시작 단계에서는 시작 정점만이 MST집합에 포함된다.
  2. 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 가중치를 가진 간선으로 연결된 정점을 선택하여 트리를 확장한다.
  3. 위 과정을 n-1개의 간선을 가질 때까지 반복한다.

**3. Kruskal VS Prim**
- 크루스칼은 간선 위주 알고리즘, 프림은 정점 위주 알고리즘
- 프림은 시작점을 정하고, 시작점에서 가까운 정점을 선택하면서 트리를 구성하여 그 과정에서 사이클이 이루지 않음. <br/>하지만 크루스칼은 시작점을 따로 정하지 않고 최소 비용의 간선을 차례로 대입하면서 트리를 구성하기 때문에 사이클이 이루어 지는지 항상 확인해야 한다.
- 프림은 최소 거리의 정점을 찾는 부분에서 자료구조의 성능에 영향을 받는다.
- 크루스칼은 간선을 기준으로 정렬하는 과정이 오래 걸린다.
- **간선의 개수가 작은 경우 크루스칼, 간선의 개수가 많은 경우에는 프림**

[참조]<br/>
<a href="https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html" rel="nofollow">https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html </a>

<a href="https://velog.io/@fldfls/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-MST-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98" rel="nofollow">https://velog.io/@fldfls/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-MST-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 </a>