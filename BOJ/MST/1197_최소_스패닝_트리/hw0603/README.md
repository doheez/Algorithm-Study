## Info
<a href="https://www.acmicpc.net/problem/1197" rel="nofollow">1197 최소 스패닝 트리</a>

## ❗ 풀이
MST를 구축하는 간단한 문제이다. Prim알고리즘을 사용하여 풀이하였다.  
MST는 모든 정점들이 연결되어 있어야 하고, 사이클이 없어야 하며, 총 노드 개수를 N개라고 할 때 (N-1)개의 간선을 갖는 가중치 합이 최소인 트리이므로, 다음과 같이 구축할 수 있다.  
1. 최초 MST 집합에는 시작 정점만 포함
2. MST집합과 인접한 노드들 중, 가중치가 가장 작은 간선으로 이어져 있는 노드를 MST 집합에 추가
3. 위 과정을 트리가 (N-1)개의 간선을 가질 때 까지 반복

좀 더 코드 관점에서 보면, (2) 에서 가중치가 가장 작은 간선을 선택하기 위해 `heapq`를 사용할 수 있다.  
  
먼저 초깃값이 `(0=시작노드로 가는 간선의 가중치, 1=시작노드)` 인 `heapq`를 선언한다. 단 이때 시작노드는 MST 특성상 1번 노드가 아닌 임의의 어떤 노드가 되어도 조건을 만족한다.  
다음으로는 `heapq`에서 `pop()` 하여 현재 힙큐(현재 MST 집합과 인접한 노드들)에서 가장 가중치가 작은 원소를 뽑는다.  
그 노드가 아직 방문하지 않은 노드라면, 최종 선택(방문처리->카운트 증가->누적 가중치 증가) 한다.  
노드가 선택되었으므로, `heapq`에 현재 MST 집합의 인접노드들의 정보를 유지하기 위해 그 노드의 인접한 노드들을 모두 `push()` 해 준다.  
  
간선이 `(N-1)`개 선택될 때 까지 위 과정을 반복하면 되고, 시작점부터, 모든 정점들을 탐색하는데, 각 정점들을 대상으로 이 다른 정점들을 `heapq`에서 `pop()`하는데 소요되는 시간은 `O(VlogV)`이고, 정점들에서 인접한 정점을 `push()`하는 것은 최대 `E` 번이며, `heapq`에 최대 `V`개의 정점이 들어오기 때문에 `O(ElogV)`가 된다.  
따라서 최종 시간 복잡도는 `O(VlogV + ElogV)`인데, 보통은 간선 수가 정점 수보다 많기 때문에 `O(ElogV)`를 최종 시간 복잡도로 표현한다.

## ❗ 추가 지식
MST 관련.. 프림 알고리즘 구현 코드

## 🙂 마무리
우선 가장 간단한 MST 구축 알고리즘인 프림 알고리즘으로 풀어 보았는데, 나중에는 Kruskal로도 풀어 봐야겠다.  
생각보다 알고리즘은 간단한데 코드로 구현할 때 깔끔하게 떠오르지 않았다.
