## Info

<a href="https://www.acmicpc.net/problem/1780" rel="nofollow">1780 종이의 개수</a>

## ❗ 풀이

분할정복은 하나의 큰 문제를 성격이 같은 다수의 문제로 쪼갰을 때
독립적으로 시행할 수 있으면 재귀함수로 병렬처리 하는 방법이다

이 문제는 종이를 9개로 나누고 검사하는 작은 문제로 쪼갤 수 있고, 이 작은 문제들은 서로 독립적이니 분할정복으로 풀면 된다!

재귀호출을 하는 경우는 종이의 수가 다 같은 수가 아닐 때 뿐이니
그 부분만 따로 `if(first != paper[i][j])`을 이용해 처리해 주었다

`void cut(int row, int col, int n)`<br/>
종이를 자르는 함수의 인자로 종이의 첫 번째 시작 행, 시작 열, 잘린 종이의 변의 길이로 주어 따로 배열을 주지 않아도 처리할 수 있도록 하였다

## ❗ 추가 지식

정석 재귀함수에선 함수 처음에 탈출조건을 만들어줘야 한다<br/>
하지만 이 문제는 탈출 조건일 때 불필요하게 for문을 거치지 않아 탈출조건을 처음에 적지않았다<br/>
재귀 호출을 할수록 오버헤드가 쌓이니 가지치기를 잘하는 것이 재귀 문제의 핵심이다<br/>

sb.append().append().append()하는것 보다 append 하나를 for문을 돌리는 것이 더 빠르다

## 🙂 마무리

이번 문제를 풀면서 재귀함수 문제에선 탈출 조건과 함수 호출 시 넘겨주어야할 정보를 잘 생각해 보아야 문제가 쉽게 풀린다는 사실을 뼈저리게 느꼈다<br/>
그리고 무지성이게 이중포문안에 또 포문을 도는 구조가 마음에 안들어서 이게 맞나?했는데 대부분의 사람들이 이렇게 푼 것을 확인할 수 있었다<br/>
그것을 보고 내 풀이가 무지성인 풀이는 아니었구나라고 생각하고 내 평균적인 코딩머리에 안심했다<br/>



