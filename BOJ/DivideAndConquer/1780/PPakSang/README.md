# 🔣 알고리즘 : Divide and Conquer

큰 문제를 풀 수 있는 작은 문제들의 합으로 해결하는 알고리즘으로, Dynamic Programming 과 간혹 헷갈릴 수 있다.<br><br>

**위키백과의 정의** 에 따르면 분할 정복 알고리즘(Divide and conquer algorithm)은 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘이다.<br><br>

구체적으로는 Dynamic Programming 은 부분해를 다음 단계에 이용하는 Memoization 기법을 사용하는데 반해<br>
Divide And Conquer 는 각각의 부분해가 다음 단계에 영향을 미치지 않는다.<br><br>

여기서 부분해란 피보나치 수열을 생각해보자면 P(0), P(1) ... P(N) 에서 N에 따른 값을 의마한다.<br>
다만 피보나치는 P(N) = P(N-1) + P(N-2) 의 이전 단계의 부분해를 활용하는 구조이므로 DP로 풀이하곤 한다.<br><br>

이와 유사하지만 Memoization 기법을 사용하지 않는 Divide And Conquer 방식을 생각해보자면 아래와 같은 예시가 있다.<br>
색종이를 계속해서 4등분 하는데, 특정 조건에 부합하는 색종이 가 존재하면  그 색종이를 버린다. N번 시행후에 몇개의 색종이가 존재하는가<br>
또는 Merge Sort 가 대표적인 예시이다.

## ❗ 알고리즘

분할(색종이를 자르는 것) 정복(색종이 영역 탐색 후 조건 부합 여부에 따른 동작 작성)<br>
색종이를 9구역으로 자르고 각 구역별로 완전 탐색을 수행하였다.<br>
분할의 핵심인 큰 문제 영역을 작은 문제 영역으로 축소시키는 방법을 생각해내면 수월한 문제<br>
(다 같을 때 vs 그 외) 의 단 두가지 조건 분기로 이루어져 있다.

## ❗ 알고리즘 외

대충 주먹구구로 반복문 수행횟수가 1억이 넘어가면 1초 시간제한에 걸릴 위험이 있다고 한다.

## 🙂 정리

이걸 재귀 9개를 돌리나? 했던 문제.<br>
그 방법 말곤 생각이 안나서 그냥 제출이나 해보자 하고 썼더니 맞췄다. ~~역시 실버 문제~~<br>
최악의 경우 첫 번째 for 문을 약 480만 회(3^7 * 3^7) 을 돌아야해서 걱정했는데, 우선은 최악의 경우에 빠지면<br>
그 뒷 상황(색종이를 자르고 난 뒤 재확인할 때)에는 낙관적인 경우가 더 많아지기 때문에 시간초과에 걸리지 않는 것 같다. <br>
