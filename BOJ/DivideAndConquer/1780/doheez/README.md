## Info
<a href="https://www.acmicpc.net/problem/1780" rel="nofollow">1780 종이의 개수</a>

## ❗ 풀이
종이(2차원 배열)의 첫 행 첫 열 데이터를 기준값으로 삼고 종이 전체를 비교해서 종이가 같은 수로만 이루어져 있는지를 검사한다. 
모두 동일한 수라면 해당 수의 개수를 1 증가시키고,
아니라면 종이를 9등분하여 각각의 종이를 다시 재귀 함수로 돌린다. 
재귀는 종이가 같은 수로만 이루어져 있거나, 한 개의 수로만 이루어져 있을 때 종료된다.

## ❗ 추가 지식
중첩 반복문 내부에서 조건을 걸어 바깥쪽 반복문을 탈출하고 싶을 때, JS에서는 반복문에 붙인 이름을 break해서 탈출할 수 있다.
```javascript
outer: for (let i = 0; i < n; i++) {
  inner: for (let j = 0; j < n; j++) {
    if (firstNum !== paper[i][j]) {
      checkSamePaper = false;
      break outer;
    }
  }
}
```

## 🙂 마무리
종이를 9등분해서 잘린 종이의 크기 `newN`은 원래 종이의 크기 `N`에 따라서 달라진다. 
따라서 종이를 자르는 코드(2차원 배열의 일부를 복사하는 코드)에서 배열의 index로 `newN`을
사용한 식을 작성해야 하는데, 내가 `N`이 9인 경우만 생각하고 `newN` 대신 상수 `3`을 사용해서 문제를 계속 틀렸었다.
문제 풀이 로직은 아무리 확인해봐도 맞는 것 같은데 틀렸다고만 떠서 틀린 곳을 찾느라 시간을 많이 썼다.
앞으로는 이런 일이 없도록 input 값에 따라 달라지는 값을 참조할 때에는 꼭 조심해서 코드를 작성해야겠다.
