## Info
<a href="https://www.acmicpc.net/problem/14226" rel="nofollow">14226 이모티콘</a>

## ❗ 풀이
목적 상태까지 도달하기 위한 최단거리(시간)을 구해야 하므로 DP+BFS를 사용하여 풀이한다.  
`status = (출력된 이모티콘 수, 클립보드에 저장된 이모티콘 수)`  
`dp[status] = status로 도달하기 위한 최소 시간`  
으로 정의한다.  
  
문제에서 주어진 3가지 종류의 연산(복사, 붙여넣기, 삭제)을 BFS 반복문 안에서 조건문을 통해 각각 구현하고, 그 결과를 `dp`딕셔너리에 계속 기록해 줌과 동시에 큐에 `append()` 해 준다.  
큐에서 `status`를 `pop()` 했을 때, 현재 출력된 이모티콘의 개수가 문제에서 입력받은 `S`와 값이 동일하면 출력이 완료된 것이므로 그 때의 상태를 출력하면 정답.

## ❗ 추가 지식
None

## 🙂 마무리
<a href="https://www.acmicpc.net/problem/17070" rel="nofollow">파이프 옮기기 1</a> 문제처럼 아예 세 가지 경우 별로 DP 테이블을 따로 만들어서 생각해야 하나.. 고민하다가 모르겠어서 풀이를 참고했다.  
알고리즘1 수업을 들으면서 DP 문제를 테이블 채우기에만 한정지어서 생각하지 말라는 교수님이 말씀이 있었는데, 이 문제가 그런 경우인 것 같다.  
보통 DP문제들은 DP 배열을 선언해 두고, 인덱스 순으로 반복문 안에서 값을 채워넣는 정형화된 문제들이 많은데 이번 문제는 아니였다.  
딕셔너리 형태로 DP 정보를 저장하는 방식은 생각해 본 적이 없었는데, (사실 이번 문제에서는 큰 리스트를 선언해 두고 참조해도 되긴 하지만) 앞으로는 문제를 봤을 때 이렇게 푸는 것도 선택지에 넣어 두고 고민해 봐야 할 것 같다.
