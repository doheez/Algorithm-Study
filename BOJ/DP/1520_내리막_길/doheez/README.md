## Info
<a href="https://www.acmicpc.net/problem/1520" rel="nofollow">1520번: 내리막 길</a>

## ❗ 풀이
dfs로만 문제를 풀이하면 내리막길 해답 중 하나인 특정 경로가 또 다른 경로의 일부와 겹칠 때, 곧바로 탐색를 종료하는 게 아니라 이미 탐색했던 길을 다시 끝까지 탐색하는 일이 생긴다. 이 과정에서 안 해도 될 추가적인 연산이 발생하므로 시간 초과가 일어난다. 따라서 메모이제이션을 통해 연산의 수를 줄여줘야 한다.

`dp[i][j]`를 `arr[i][j]`에서 `arr[M-1][N-1]`까지 갈 수 있는 경로의 수라고 하자.

탐색 여부를 표시하기 위해 dp 배열은 모두 -1로 초기화한다. (해당 위치에서 갈 수 있는 경로가 없다고 하더라도, 탐색을 끝마친 노드라면 0으로 표시)

자식 노드가 벽이 아니고, 자식 노드가 본 노드보다 값이 작을 때에만 이동한다는 조건을 지키면서 dfs로 방문한 적 없는 노드의 상하좌우를 탐색한다. 이때, 탐색하면서 얻는 경로의 수를 본 노드의 dp값에 더하면서 dp 배열을 갱신시켜주면 마지막엔 `dp[0][0]`에 우리가 구하고자 하는 경로의 개수가 담기게 된다.

## ❗ 추가 지식


## 🙂 마무리
dfs를 사용해야겠다는 것까지는 생각을 했는데, 이번에도 역시나 dp를 무엇으로 설정해야 할지에서부터 막혔다.

참고한 블로그
- https://yabmoons.tistory.com/340
- https://wootool.tistory.com/83