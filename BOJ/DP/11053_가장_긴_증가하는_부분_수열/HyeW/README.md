## Info

<a href="https://www.acmicpc.net/problem/11053" rel="nofollow">11053 가장 긴 증가하는 부분 수열</a>

## ❗ 풀이

dp배열 `mem[]`을 만들었다.<br/>
이 배열에 자신의 원소를 포함했을 때 해당 인덱스까지 가장 긴 수열의 길이를 저장하여 문제를 해결하면 간단하다.<br/>
예를 들어, mem[4]에는 arr[4]값을 포함하여 arr[4]까지의 수열을 봤을 때 가장 긴 부분 수열의 길이를 저장한다.<br/>

```java
if( arr[j] < arr[i] && mem[i] < mem[j] + 1) {
	mem[i] = mem[j] + 1;
}
```
arr[i]을 포함한 arr[i]까지의 가장 긴 수열을 찾으려면<br/>
arr[i]이전의 수들을 체크하고 그 수가 arr[i]보다 작고, mem[i]가 mem[j]+1 보다 작을 경우 <br/>
arr[j]까지의 가장 긴 부분 수열 뒤에 arr[i]를 붙일 수 있는 조건이 완성된다.
그렇게 for문을 돌려 bottom-up 방식으로 주어진 배열의 가장 긴 증가하는 부분 수열을 구할 수 있다

## ❗ 추가 지식

간단한 if문은 삼항연산자를 사용해 만들면 더 간단하다.

## 🙂 마무리

가장 긴 증가하는 부분 수열과 같은 문제 유형들이 많은데<br/>
배열만드는 방법을 잘 기억하자.br/> 

이거 진짜 머리 부여잡고 메모이제이션 어떻게 해야 하는건지 생각했는데<br/>
그 다음 구현을 전혀 못하겠어서 포기했다 뭔가 내가 해결할 수 있을 것만 같아 아쉬우면서 후련..<br/>
주변에서 항상 하는 말이지만 알고리즘 문제풀 때 2시간이상 고민해도 안풀리면 답을 보는게 맞다고 하는데<br/>
다음부턴 시간끌지말고 그냥 답을 봐야겠다^^
