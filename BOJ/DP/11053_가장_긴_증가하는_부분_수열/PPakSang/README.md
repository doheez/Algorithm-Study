## Info

문제 출처 : [BOJ 가장 긴 증가하는 부분수열](https://www.acmicpc.net/problem/11053)

## ❗ 풀이

dp[n] = dp[n-1].. 의 과정을 for(i=0 -> i=n) getDp(i) 의 방식으로 표현<br>
함수 내부에서는 dp[i] 를 찾는 과정이 나와있는데, 함수(i) 를 dp[i] 로 볼 수 있다.<br>
dp[i] 를 찾는 점화식은 i-1 부터 0까지 내려가면서...k dp[k] + 1 이 최대인 것을 구하면 된다<br>
이 풀이가 가능한 것이 조건 분기 기준이 현재 수보다 작은 수를 발견하면, 즉 작은 수를 마지막 수로 하는 부분수열에서 현재 수를 추가하는 개념<br>

## ❗ 추가 지식

for() {재귀 return} => n^2<br>
for() {재귀} => n^3

## 🙂 마무리

dp[i] 의 기준을 잘 세울 필요가 있다. i를 기준으로 현재 과정을 표현할 방법을 찾자<br>
전체 문제 상황을 전부 활용할 수 있다. 이 문제를 풀면서도 완전 탐색을 해야하나? 싶었는데<br>  
시간제한 + 완전탐색 의심이 들면 dp 전체 탐색을 한번 고려해보도록 하자 <br>
