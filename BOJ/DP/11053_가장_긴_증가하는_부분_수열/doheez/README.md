## Info

<a href="https://www.acmicpc.net/problem/11053" rel="nofollow">11053번: 가장 긴 증가하는 부분 수열</a>

## ❗ 풀이
- `sequence`: 입력으로 받은 수열
- `dp[i]`: `sequence[i]`를 마지막 엘리먼트로 생각하는 수열의 가장 긴 증가하는 부분 수열 길이

`sequence`를 `index == 1`부터 차례로 탐색한다. 현재 탐색 중인 엘리먼트의 index를 `a`라고 하자. `a`보다 낮은 index를 갖는 엘리먼트들 중 `sequence[a]`보다 값이 작은 엘리먼트끼리 비교하여 그 중 `dp`값이 가장 큰 엘리먼트의 index를 `b`라고 할 때, `dp[a] = dp[b] + 1`로 설정한다. 이렇게 sequence의 마지막 index까지 탐색하면, dp 배열에서 가장 큰 값이 가장 큰 증가하는 부분 수열의 길이가 된다.

## ❗ 추가 지식
나도 모르게 자꾸 if문을 중첩해서 사용하려고 하는데, 그러니까 오히려 가독성이 더 떨어지는 느낌이다. 비교할 조건이 몇 개 없다면 if문 한 줄에 논리 연산자로 연결하기.

## 🙂 마무리
dp 문제는 무조건 점화식 세우기라는 강박이 생겨버려서 처음부터 수식으로만 생각하려 했더니 아이디어가 잘 떠오르지 않았다. 너무 어렵게 생각하지 말고 손으로 그림도 그려가면서 답을 찾아야겠다.

그리고 내 풀이의 시간복잡도는 `O(N^2)`인데 찾아보니 `O(NlogN)` 풀이법도 존재했다. 아직은 dp 문제와 친해지는 단계이므로... 몇 개 더 풀어보고 나면 저 풀이법도 숙지해야지.