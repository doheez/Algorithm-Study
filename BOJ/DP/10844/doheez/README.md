## Info

<a href="https://www.acmicpc.net/problem/10844" rel="nofollow">10844번: 쉬운 계단 수</a>

## ❗ 풀이
길이가 `N`이고 1의 자릿수가 `i`인 계단 수는 다음 두 가지의 선행 계단 수부터 만들어진다.

1. 길이가 `N-1`이고 1의 자릿수가 `i-1`인 계단 수의 오른쪽에 `i+1`을 덧붙인 것
2. 길이가 `N-1`이고 1의 자릿수가 `i+1`인 계단 수의 오른쪽에 `i-1`을 덧붙인 것

따라서 길이가 `N`이고 1의 자릿수가 `i`인 계단 수의 개수는 점화식 `dp[N][i] = dp[N-1][i-1] + dp[N-1][i+1]`로 표현할 수 있다.<br>
단, 길이가 `N`이고 1의 자릿수가 `0`인 계단 수는 길이가 `N-1`이고 1의 자릿수가 `1`인 계단 수로부터만 만들어질 수 있으며,<br>
길이가 `N`이고 1의 자릿수가 `9`인 계단 수는 길이가 `N-1`이고 1의 자릿수가 `8`인 계단 수로부터만 만들어질 수 있으므로 따로 처리한다.

## ❗ 추가 지식
1. 이차원 배열 생성 시 `Array.from(Array(rowCnt), () => Array(colCnt).fill(initialValue));` 형태로 생성할 수 있다.
2. 배열 API 중 `reduce()`를 사용하여 간편하게 값을 누적할 수 있다.

## 🙂 마무리
DP 문제가 분할 정복 문제와 비슷하게 풀이될 것이라는 생각에 첫 시도에서 재귀 함수를 사용해서
가지치기 형태로 계단 수를 구했더니 시간 초과로 문제 풀이에 실패했다.
한참을 생각하다가 아이디어가 떠오르지 않아서 정석 풀이를 참고했는데
대부분이 점화식을 사용해서 문제를 풀고 있었다.
점화식을 좀처럼 떠올리기가 힘들었는데, 출력 결과를 보고 규칙을 찾는 연습을 좀 더 해야 할 것 같다.

그리고 1000000000으로 나눈 나머지를 구하는 식을 마지막에 한 번만 작성했더니 올바른 결과가 나오지 않아서 틀린 곳을 찾느라 시간을 많이 썼다.
자바스크립트에서는 `Number.MAX_SAFE_INTEGER = 2^53 - 1`인데 계단 수의 개수를 구할 때 이보다 큰 수가 생긴 게 원인이었다.
계단 수 개수 자체를 구할 때부터 `%1000000000`를 해주어야 했다.
