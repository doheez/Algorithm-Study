## Info
<a href="https://www.acmicpc.net/problem/2096" rel="nofollow">2096 내려가기</a>

## ❗ 풀이
`dp[i][j] = 를 (i, j)에 도착했을 때 얻을 수 있는 점수의 (최대/최소)` 라고 정의한다.  
0행은 출발 행이므로 `matrix[0]`행의 값과 일치할 것이고, 1행부터는 이전 지점에서 획득한 점수를 고려해 주어야 한다.  
- 0열이 현재 위치인 경우
  - 0열과 1열만 이전 위치가 될 수 있다.
- 1열이 현재 위치인 경우
  - 0, 1, 2열 모두 이전 위치가 될 수 있다
- 2열이 현재 위치인 경우
  - 1열과 2열만 이전 위치가 될 수 있다.

위와 같은 위치의 순서 관계를 고려하여, 이전 위치가 될 수 있는 지점에서의 dp값의 최대/최소를 비교하여 현재 좌표의 dp 값으로 업데이트 시키는 것이 기본 아이디어이다.  
  
다만, 문제의 메모리 제한이 아주 빡빡하게 잡혀 있어 단순히 위의 내용대로만 구현해서는 메모리 조건을 통과하지 못했다.  
```
import sys
import random
temp = [[random.randint(1,10),random.randint(1,10),random.randint(1,10)] for i in range(100000)] 
top_size = sys.getsizeof(temp)
bottom_size_sum = 0  
for bot in temp:
    bottom_size_sum += sys.getsizeof(bot)

print((top_size + bottom_size_sum) / (1024 * 1024), "Mb")
        
# 결과 = 9.178604125976562 Mb
```
위 예시에서 알 수 있듯, 문제 입력의 최댓값인 int형 숫자 3개로 이루어진 순서쌍을 10만번 입력받아 리스트에 저장하는 것 만으로도 이미 주어진 메모리 조건을 초과하게 된다. 따라서 미리 입력을 받아서 저장해 두는 것이 아니라 반복문 안에서 해당 입력 데이터가 필요할 때 입력버퍼에서 데이터를 가져와서 사용하고, 그 데이터는 저장하지 않고 계산 후 버려야 한다.  
  
DP 테이블 역시 행 개수만큼 미리 선언해 두는 것이 아니라, 계산에 필요한 최소 행 (이 문제에서는 두 행) 크기만큼의 리스트를 선언한 후에, 계산이 끝나면 인덱스를 swap 하는 방식으로 접근하여 메모리 사용량을 최대한 줄여야 한다.

## ❗ 추가 지식
이런 풀이법(DP 테이블을 재활용하면서 메모리를 절약하는 테크닉)도 슬라이딩 윈도우 기법으로 부르기도 한다.

## 🙂 마무리
문제 자체는 그렇게 어렵지 않았으나, 단순히 생각한 대로 구현했을 때 메모리 초과가 떠서 그것을 해결하는 데 애를 좀 먹었다. DP 문제를 풀면서 예전에 생각했던 기법(필요한 부분만 저장하고 swap)을 활용하여 직접 메모리를 줄여볼 수 있는 기회가 되는 문제였지만, 입력 데이터 역시 그와 유사하게 필요한 부분만 읽고 버리는 생각을 처음부터는 하지 못했었다. 지금까지 풀어보지 못했던 신선한 유형이였던 것 같다.
