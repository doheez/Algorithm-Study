## Info

<a href="https://www.acmicpc.net/problem/11057" rel="nofollow">11057 오르막 수</a>

## ❗ 풀이
길이가 N인 i로 끝나는 오르막 수의 개수를 `dp[N][i]`라고 하자.  
길이가 3인 5로 끝나는 `__5`형태의 오르막 수의 개수는 `dp[3][5]`에 저장될 것이고, 우리가 원하는 결과는 `sum(dp[N])`으로 구할 수 있다.  
  
이때, `dp[3][5] = dp[2][0] + dp[2][1] + ... + dp[2][5]` 의 점화식이 성립한다.  
마찬가지로, `dp[3][4] = dp[2][0] + dp[2][1] + ... + dp[2][4]` 역시 성립하고, 중복되는 부분을 고려했을 때, 최종적으로 다음과 같은 식으로 나타낼 수 있다.  
`dp[3][5] = dp[3][4] + dp[2][4]`  
  
이를 좀 더 일반화하면, `dp[N][i] = dp[N][i-1] + dp[N-1][i] (i > 0)` 가 되고,  
`i==0`의 경우. 즉, `dp[N][0]`은 항상 1이 되므로 dp배열을 초기화 할 때 모두 1로 초기화 한 후 `0 < i < 10` 인 범위 내에서만 생각해 주면 된다.


## ❗ 추가 지식
처음에 이차원 배열 할당할 때 `dp = [[1] * 10 for _ in range(N+1)]` 형태로 쓰지 않고 `dp = [[1] * 10] * (N+1)` 처럼 할당하였더니, 계산 후 dp배열의 모든 행의 값이 같아지는 결과가 나왔다.  
```
>>> dp = [[1] * 10] * 3
>>> [id(dp[i]) for i in range(3)]
[2975167372736, 2975167372736, 2975167372736]
```
어떻게 된 일인지 확인해 보니, 저렇게 선언할 경우 각 행의 id 값이 모두 중복으로 부여돼서 한 행의 값이 수정 때, 모든 행의 값이 같이 바뀌고 있었다.  
아마 리스트 곱 연산 시에 값 자체를 복사하는 deep copy 가 아닌 레이블에 레퍼런스를 추가하는 shallow copy로 동작하는 것으로 추정된다.
```
>>> dp = [[1] * 10 for _ in range(3)]
>>> [id(dp[i]) for i in range(3)]
[2975167400064, 2975167398464, 2975167392960]
```
list comprehension 형태로 초기화 할 경우 각 행이 고유한 id 값을 가지는 것을 확인할 수 있다.  
2차원 배열 할당할 때는 `*` 연산자는 사용하지 말아야겠다.


## 🙂 마무리
처음에는 `dp[3][5] = dp[2][0] + dp[2][1] + ... + dp[2][5]` 와 같이 합 형태의 식으로만 구하려고 생각을 했었는데, 규칙을 조금 더 들여다 보니 여전히 중복되는 연산을 찾을 수 있었고, 최종적으로는 그것을 제거하여 실행시간을 단축시킬 수 있었다.  
점화식 나왔다고 바로 쓰지 말고 중복되는 연산을 계속 찾아 보자!
