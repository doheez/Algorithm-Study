## Info
<a href="https://www.acmicpc.net/problem/14891" rel="nofollow">14891 톱니바퀴</a>

## ❗ 풀이
시뮬레이션 문제인 만큼 특별한 알고리즘을 사용하기보다 실제 기어의 움직임을 생각하여 그대로 구현했다.  
인덱스 2번(오른쪽)과 인덱스 6번(왼쪽)에 초점을 맞추어 값을 조사하고, 맞닿은 곳의 값이 다르면 톱니가 맞물려서 같이 돌아간다고 생각하고, 값이 같으면 톱니가 연결되어 있지 않아 움직이지 않는다고 생각하고 풀었다.

## ❗ 추가 지식
`deque.rorate(n)` 를 사용하여 덱의 원소들을 `n` 값만큼 회전할 수 있다.  
n이 음수이면 왼쪽으로 회전하고, n이 양수이면 오른쪽으로 회전한다.

## 🙂 마무리
처음에는 단순하게 리스트를 활용하여 `gear = gear[1:] + [gear[0]]` 과 같은 방식으로 회전을 구현했는데, 이럴 바에는 양 끝단에서 모두 push/pop이 가능한 덱을 활용하는 것이 더 낫겠다고 생각하여 검색을 하다가 `deque.rotate()` 라는 이 문제와 딱 맞는 메소드를 발견했다.  
  
덱은 BFS 풀이 할 때 매 번 썼던 자료구조인데 항상 쓰던 메소드만 쓰다 보니 `rotate()`의 존재 자체도 모르고 있었다. 알고리즘 문제 풀이할 때 쓸 만 한 함수들을 한 번 다시 훝어봐야겠다.
