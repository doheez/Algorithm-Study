## Info
<a href="https://www.acmicpc.net/problem/1753" rel="nofollow">1753 최단경로</a>

## ❗ 풀이
가장 기본적인 다익스트라 문제.  
다익스트라 알고리즘을 적용할 때 특정 정점과 인접한 노드를 한 번에 탐색할 수 있도록,
그래프를 구축할 때 `graph[v] = 정점 v와 인접한 (정점 번호, 가중치) 의 리스트` 가 되도록 구축한다.  
다음으로는 시작 정점으로부터 각 정점까지의 최단거리를 저장할 `mindist` 리스트를 선언하고, 초깃값을 무한대로 준다.
  
그래프가 구축되면 다익스트라 알고리즘을 적용하면 되는데,  
1. 우선 시작 정점과 시작 정점의 거리는 항상 0이므로 `mindist[K] = 0`
2. `heapq`로 사용할 리스트를 하나 선언하고, 초깃값으로 시작 노드에 대한 정보인 `(mindisk[K], K)`를 설정한다.
   - 이때, `(거리, 노드 번호)` 순으로 저장하는 이유는 `heapq`의 기본 대소 비교를 이용하기 위함.(거리순 정렬)
3. `heapq`에서 원소를 `pop()`하여 큐 안의 정점들 중 가중치가 가장 작은 정점을 꺼낸다.
4. 꺼낸 정점의 거리 정보가 현재 `mindist`에 기록된 거리 정보보다 크다면, 그 정점은 조사할 필요가 없으므로 `continue`
5. 꺼낸 정점의 거리 정보가 현재의 최솟값보다 작다면, 해당 정점의 인접 노드를 탐색해 주어야 한다.  
   1. 그 정점의 모든 인접 노드들을 순회하면서, 현재 구한 최솟값의 경로인 `mindist[인접노드]`보다 `시작노드->현재노드->인접노드` 가 더 작다면, 그 인접 노드에 대한 최단 거리는 `mindist`에 업데이트한다.
   2. 인접 노드의 최단거리가 업데이트되었으므로, 그에 따른 파급효과(갱신된 최단거리를 거쳐 갔을 때 지금까지 구한 거리보다 더 짧게 도달할 수 있는 노드가 있는가?)를 조사해야 하므로, `heapq`에 그 인접 노드 정보를 추가한다.
6. 큐가 빌 때 까지 **3**~**5**를 반복하고 난 후의 `mindist`가 각 노드의 최단 경로이다.

## ❗ 추가 지식
다익스트라 알고리즘에 대한 구현법, `heapq`를 사용하여 시간 복잡도를 줄이는 법.

## 🙂 마무리
제일 기본적인 다익스트라 문제였는데, 다익스트라에 대한 기본적인 개념이 잡혀있지 않아서 꽤 애를 먹었다. 처음에는 단순한 인접 행렬 형태로 VxV의 이차원 리스트로 그래프를 구현했었는데, 이것저것 찾아 보다 보니 현재 코드와 같이 한 정점과 연결되어 있는 정점의 정보들을 리스트로 갖고 있는 편이 더 효율적이겠다 싶더라.  
이거 말고도 `heapq`를 어떻게 사용해야 하는지, 왜 `heapq` 사용 시 `visited` 배열 없이도 구현이 가능한지 등 여러 기본적인 개념이 흔들려서 한 문제 푸는데 시간이 오래 걸린 것 같다.  
이번 문제를 계기로 다익스트라를 제대로 이해했으면..좋겠지만 그건 다른 문제들을 많이 풀어 봐야 알 것 같다.
