## Info
<a href="https://www.acmicpc.net/problem/2668" rel="nofollow">2668 숫자고르기</a>

## ❗ 풀이
그래프를 정의할 때, 문제에서 주어진 input에서 1행에 해당하는 데이터들이 같은 열의 0행을 가리키고 있다고 생각하고 그래프를 정의하면 다음과 같다.  
|1|2|3|4|5|6|7|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|3|1|1|5|5|4|6
```
arr[1]: [2, 3]
arr[2]: []
arr[3]: [1]
arr[4]: [6]
arr[5]: [4, 5]
arr[6]: [7]
arr[7]: []
```
해당 그래프에서는 `arr[i]`의 원소는 i번째 노드와 이어져있다는 의미이므로 노드 번호를 참조하여 순차적으로 탐색할 수 있다.  
문제의 조건과 같이 첫째 줄에서 뽑은 숫자들의 집합들이 둘째 줄의 숫자 집합과 같으려면, 다음과 같이 노드들이 사이클을 이루고, 그 사이클을 이루는 노드들을 선택하면 된다.
```
1 -> 2 (사이클 형성 X)
1 -> 3 -> 1 -> 3 -> .... -> 1 -> 3 (사이클 형성)

5 -> 4 -> 6 -> 7 (사이클 형성 X)
5 -> 5 -> 5 -> 5 -> .... -> 5 -> 5 (사이클 형성)
```
노드들의 탐색은 DFS를 이용하여 탐색하고, 각 DFS 깊이에서 지금까지 왔던 경로들을 유지하고 있으면 새로 들어온 노드가 이미 경로상에 존재하는 노드인지 파악하여 사이클을 형성하는지 여부를 확인할 수 있다. (지금까지의 경로에 있는 노드가 다시 들어오면 사이클이 형성되는 것)
  
`dfs()` 함수 안에서 경로를 저장하기 위해 사용하는 `pathset` 이외에, 전역 `visited` 배열을 별도로 두어 이미 탐색한 노드에 대한 불필요한 dfs 탐색을 방지할 수 있다.


## ❗ 추가 지식
`set()`의 데이터 추가는 `set.add()` 메소드로 할 수 있고, 한 번에 여러 데이터를 추가할 때는 `set.update()` 메소드를 사용한다.


## 🙂 마무리
이번 문제도 대체 이게 왜 그래프 문제인지 감이 안 잡혀서ㅎㅎ; 풀이를 살짝 참고했다. 어떤 형태로 그래프 형태를 잡을지만 참고하고 나니까 술술 풀리는 감이 있었다. 그동안 BFS, DFS 문제에서는 항상 이차원 배열이 주어지고 4방향 혹은 8방향으로 탐색하면서 문제마다 조건만 달라지는 경우가 많았는데 이번 문제처럼 아예 주어진 배열이 달라지니 헷갈렸다. DP가 점화식을 어떻게 설정할지부터 고민해 보는 문제라 한다면, 이런 류의 그래프 탐색 문제는 그래프를 어떤 데이터를 기준으로 만들지부터 고민해 볼 필요가 있을 것 같다.

