## Info
<a href="https://www.acmicpc.net/problem/1926" rel="nofollow">1926번: 그림</a>

## ❗ 풀이
BFS를 이용해서 풀었다. 방문을 체크하는 배열을 따로 두지 않고, 방문했을 경우 기존 도화지 이차원 배열의 엘리먼트를 1에서 0으로 바꿔주어 방문 노드를 표시했다.

도화지 전체를 이중 for문으로 검사해서 1인 노드를 찾으면 해당 영역의 그림을 bfs로 탐색했고, bfs 탐색이 끝날 때마다 그림의 개수를 증가시켰다.

그림 각각의 넓이는 bfs 함수 안에서 조건에 맞는 노드를 방문할 때마다 1씩 증가시켰다.


## ❗ 추가 지식
`Math.max(이 부분)`에는 배열 자체를 넣는 것이 아니라, 숫자들을 일일이 나열해주어야 한다. 그래서 `array`라는 배열의 max를 알고 싶을 때는 전개 구문을 사용해서 `Math.max(...array)`로 써주어야 한다.

## 🙂 마무리
그림 각각은 bfs이든 dfs이든 편한 그래프 탐색을 쓰면 구할 수 있겠지만, 다음 영역의 그림으로 어떻게 넘어가야 할지 좋은 생각이 떠오르지 않았다. 이중 for문으로 도화지 전체를 검사하는 것은 효율적이지 않은 방법인 것 같아서 제외하고 있었는데, 다른 사람들이 푼 방식으로 보니 대부분 전체 검사를 하더라. 별로라고 생각한 어떤 방법 외에 다른 풀이가 더 이상 떠오르지 않는다면 머뭇거리지 말고 처음 생각한 방법을 적용해 봐야겠다.