## Info

<a href="https://www.acmicpc.net/problem/14502" rel="nofollow">14502 연구소</a>

## ❗ 풀이
연구실 지도를 입력받을 때, 바이러스들의 좌표와 빈 공간의 좌표를 따로 리스트에 저장해 둔다.  
3중 for문을 사용하여 빈 공간들 중 3개를 고를 수 있는 모든 경우의 수(nC3)에 대하여 모두 벽을 배치한 후 바이러스를 전염시켜 보고, 각 경우마다 안전 구역의 개수를 구하여 최댓값을 출력한다.  
바이러스 감염은 BFS를 통하여 수행하고, 미리 저장해 뒀던 바이러스의 좌표를 큐에 넣은 상태로 BFS를 수행하여 바이러스가 도달할 수 있는 곳은 모두 바이러스로 채우면 된다.


## ❗ 추가 지식
파이썬으로 코딩하다 보면 한 번씩 뜬금없이 헷갈리는 것. `mutable` 객체와 `immutable` 객체이다.  
`[[0]*m for _ in range(n)]` 형태로 2차원 리스트를 만들면, 각 행의 id값은 각자 고유한 id가 부여되지만, 특정 행 내의 원소(`int`)들의 id는 모두 동일하게 설정된다.  
하지만, `int`는 `immutable` 객체이므로, 새로운 값을 할당하게 되면 id값이 변하므로 위와 같은 형태로 2차원 리스트를 선언하여 쓸 수 있는 것이다.  
  
만약 행을 추가할 때도 반복문을 사용하지 않고 `*` 연산자를 이용하여 2차원 리스트를 선언한다면, 2차원 리스트의 원소인 행(`list`)들은 `mutable`한 객체이기 때문에 한 행을 수정하게 되면 다른 행들의 값도 전부 변하게 된다.
```
>>> a = [[0]*m for _ in range(n)]
>>> id(a[0][0])
1399302875408
>>> id(a[0][1])
1399302875408
>>> a[0][0] = 1
>>> id(a[0][0]) # 이때 id값이 달라진다
1399302875440
>>> id(a[0][1])
1399302875408
```

## 🙂 마무리
바이러스를 전염시키는거야 당연히 BFS를 쓰겠거니..생각했는데 대체 벽을 어떤 기준으로 세워야 최적해가 나올지 도저히 생각이 안 나서 풀이를 살짝 참고했다.  
근데 결국 풀이법은 브루트포싱-_-; 맵의 크기가 생각보다 작아서 그냥 브루트포스를 써도 되려나 생각은 했었는데 설마 진짜로 그렇게 풀 줄은 몰랐다..  
DP에서 그래프로 넘어오면서 파이썬 내장 모듈들(deque나 copy 모듈 등)을 사용하는 일이 잦아졌다. 이번 문제도 나는 3중 for문을 사용해서 nC3의 벽 좌표 조합을 만들었지만, `itertools.combinations` 모듈을 사용하면 손쉽게 조합 iterator를 얻을 수 있다고 한다. 이러한 파이썬의 장점을 잘 활용하면 풀이가 훨씬 수월해질 것 같다. 만간 내장 모듈과 파이썬 특징들을 정리하는 시간을 가져야겠다.
