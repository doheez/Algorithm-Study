## Info

<a href="https://www.acmicpc.net/problem/2573" rel="nofollow">2573 빙산</a>

## ❗ 풀이

`ice`에 얼음의 위치를 저장한다.<br/>
`water`에 얼음 위치에 해당 얼음의 물과 맞닿아 있는 면의 개수를 저장한다.
<br/>
<br/>
우선 dfs는 얼음이 이어져있는지를 확인할 때 쓰였다.
그리고 빙산이 갈라지지 않았다면 `melt()`를 사용하여 얼음이 일년 지난 뒤의 모습을 구한다.
<br/>
```java
static void melt() {
        
        for (int j = 0; j < ice.size(); j++) {
            Node cur = ice.get(j);
            map[cur.x][cur.y] -= water[cur.x][cur.y];
            // 얼음이 다 녹았을때
            if (map[cur.x][cur.y] <= 0) {
                r_ice.add(cur);
            }
        }

        for (Node cur : r_ice)
            for (int i = 0; i < 4; i++) { // 주변 얼음들 w에 +1해줌
                //...
        
                if (map[dx][dy] <= 0)
                    continue;

                water[dx][dy] += 1;
            }
        ice.removeAll(r_ice);
    }
```

먼저 water배열을 이용하여 간편하게 얼음을 녹인다.<br/>
그리고 다 녹았을 경우 `r_ice`리스트에 저장한다.<br/>
r_ice에서 0이 된 얼음들을 꺼낸다. 해당 얼음 주변의 얼음들은 물과 맞닿은 면이 1증가 한 것이니
water배열에 +1을 해준다.<br/>
그리고 ice리스트에서 녹은 얼음들을 제거한다.<br/>
<br/>
main에서 `flag`는 dfs를 두번 한다면 빙산이 갈라졌다는 의미이니
첫번째 dfs를 돌았다면 true로 바꿔준다.
그래서 두번째 dfs를 돌기전에 flag를 확인하여 함수를 바로 종료시켜 불필요한 코드를 줄였다.
<br/>
또한 68번째 줄의 `if (depth == ice.size())`는 빙산이 갈라지지 않았다면
첫번째 dfs때 얼음을 다 탐색하여, dfs의 깊이와 얼음의 개수가 같을 것이므로 바로 for문을 나와 얼음을 녹이는
함수를 수행하도록 하였다.

## ❗ 추가 지식
ArrayList 함수 중 `remove(index)`를 사용하면 알아서 index를 빈칸 없이 정렬해 주고,
`removeAll(Collection<?> c)`는 다른 리스트인 ArrayList c와 중복되는 값들을 다 삭제하는 함수이다.

## 🙂 마무리

이 문제를 풀 때, 여러번의 디버깅을 하면서 코드를 몇변이나 고쳤어야 했다.<br/>
1. 맨 처음에 Node에 주변 물의 개수까지 넣어 주었는데 
해당 방법은 주변의 얼음의 위치를 구하지 못한다는 에러가 있어 `water[][]`를 두어 
따로 얼음 주변의 물의 칸 개수를 저장하였다.
2. `melt()`에서 얼음이 다 녹았을 경우 바로 주변 얼음의 물 칸의 개수를 증가시켰었다.
그러니 아직 뒤에 남아 있는 얼음들을 보기전에 water배열이 update가 되어 
뒤에 있는 얼음들은 year가 바뀌지 않았지만 바뀐 것 처럼 동작하게 되었다.
3. 또한 비슷한 실수로 `melt()`에서 얼음이 다 녹았을 경우 해당 인덱스를 바로 ice리스트에서 삭제 하였는데
   그러면 인덱스가 중간에 하나 사라지면서 뒤에 있던 요소들이 -1 씩 되어 인덱스가 엉키게 되는 문제가 생겼다.<br/>

2, 3번의 문제는 녹은 얼음을 먼저 구하고 2, 3번 행위를 하여 문제를 해결하였다.
<br/>
지금 다른 문제는 중복되는 코드가 많고 `while(ice.size() > 0) `절은 코드를 줄일 수 있을 것 같다는 것이다.
그래서 더 좋은 코드를 짜기 위해 고민해 보아야 할 것 같다.
