## Info
<a href="https://www.acmicpc.net/problem/2573" rel="nofollow">2573 빙산</a>

## ❗ 풀이
먼저 빙산의 위치를 입력받으면서 빙산이 있는 곳들의 좌표를 리스트에 따로 저장해 둔다. 그 다음 첫 번째 빙산의 위치부터 BFS 탐색을 통해 1년 단위로 바닷물과 인접한 빙산들을 녹여 나간다. 이 때, BFS 함수 안에서 탐색한 빙산의 총 개수를 리턴해 주고, 이는 BFS 함수 호출 전 미리 구해 둔 빙산의 총 개수와 비교하여 빙산이 두 조각 이상으로 나누어졌는지 검사하는데 활용한다.(BFS에서 연결된 모든 지점을 탐색하므로 두 수가 다르면 쪼개진 것).  
  
BFS 함수 내에서 각 지점의 얼음을 바로 녹여 버리면, 얼음이였던 지점이 함수 내에서 바닷물로 바뀌는 상황이 생기고, 이 경우 함수 내의 다음 루프에서 탐색할 지점의 빙산이 영향을 받게 된다.(원래 안 녹아야 하는 지점인데 갑자기 옆에 있던 얼음이 물이 되므로) 따라서 BFS 탐색 중에는 별도의 큐 `melting_q`에 녹일 지점들을 저장해 두고, 탐색이 끝난 이후에 `melting_q`에서 원소 하나씩 `pop()`하여 실제로 빙산을 녹여주면 된다.

## ❗ 추가 지식


## 🙂 마무리
분명 BFS 큐에서 visited 검증을 해 줬다고 생각했는데 계속 중복된 칸이 삽입되는 문제가 있었다. 코드를 다시 보니 큐에 넣을 때 방문 처리를 해 줘야 하는데, 다른 위치에서 이상하게 방문처리를 하고 있어서 제대로 검증이 되지 않은 것이였다. 노드를 방문 처리할 때는 내가 하는 위치가 논리적으로 맞는 위치인지 꼭 한 번 더 생각 해 볼 것.  
첫 시도만에 성공해서 기분은 좋았는데 시간이 꽤 길게 나왔다. (사실 시간 초과가 뜰 줄 알았다ㅎㅎ;) 로직이 생각만큼 깔끔하게 나오지 못했다. 더 개선할 여지가 있는지 고민해 봐야 한다.  
간단한 생각으로는 `melting_q`에 저장할 때 여러 번 녹여야 하는 빙산들을 중복 저장하는 대신 녹여야 할 횟수를 저장하고, 실제로 녹일 때 그 횟수를 참조하여 한 번에 녹여 버리면 녹이는 루프 안에서 `ice_list`에 추가할 수 있을 것 같은데, 구현을 어떻게 해야 할지 잘 떠오르지 않는다.  
  
참고) 처음에 실수했던 건데, 지금과 같이 `melting_q`에 녹여야 할 횟수만큼 노드들이 중복 저장되어 있는 경우에는 녹이는 루프 안에서 1회 녹이는 작업 이후 빙산이 남아 있다고 `ice_list`에 추가하면 안 된다! 중복으로 추가되는 문제도 있고, 그 뒤에 얼마나 더 녹이는 작업이 진행될지 알 수 없기 때문.
