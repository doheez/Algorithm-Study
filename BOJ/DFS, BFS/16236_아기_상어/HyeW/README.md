## Info

<a href="https://www.acmicpc.net/problem/16236" rel="nofollow">16236 아기 상어</a>

## ❗ 풀이

조건 중 가장 가까이 있는 물고기를 먹는 것이니 BFS를 사용하여 문제를 해결하였다.
```java
if (map[i][j] == 9) {
    q.add(new Node(i, j));
    map[i][j] = 0;
    visited[i][j] = true;
    } else if (map[i][j] != 0) {
        check = true;
        fish++;
    }
```
input을 받을때 물고기 수를 세아려 물고기가 처음부터 없는 경우 바로 출력하도록 하고
BFS함수를 돌때도 물고기를 먹고 나서 더이상 남은 물고기가 있는지 확인을 하여 불필요한
탐색을 없도록 하였다.<br/>

BFS를 돌면서 아기 상어가 거리가 같은 물고기중에 가장 위쪽, 왼쪽 물고기를 먹어야하기에 row값과 col값이 작은 인덱스를 저장하여
같은 depth의 노드들을 다 보았을때 (s가 0일때), 물고기를 먹는 행위를 하도록 했다.<br/>


## ❗ 추가 지식



## 🙂 마무리

예전에 한 번 풀었던 문제였지만 오래걸렸다.<br/>
구현문제는 생각할 경우의 수가 많아, 경우마다 분기점을 둔다고 코드가 지저분해지는 느낌을 받았다.<br/>
여기서 애를 먹은 부분은 같은 거리의 물고기가 있을때, 가장 위쪽 그다음 왼쪽에 있는 것을 먹어야 한다는 조건이었다.<br/>
간단하게 풀 수 있을 거 같아서 이것 저것 도전하였는데 결국 정석방법으로 푸는 것이 제일 깔끔한거 같다.<br/>

