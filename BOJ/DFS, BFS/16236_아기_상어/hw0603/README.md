## Info
<a href="https://www.acmicpc.net/problem/16236" rel="nofollow">16236 아기 상어</a>

## ❗ 풀이
먼저, 물고기와 상어의 위치를 입력받으면서 동시에 상어의 좌표와 물고기의 총 개수를 저장해 둔다.  
이 때, 상어의 위치(행렬에서 9)의 값은 차후 BFS를 적용할 때, '크기가 9인 물고기'로 인식하는 것을 방지하기 위하여 0으로 바꿔 준다.  
  
다음으로는 현재 상어의 위치 좌표를 전달받고, 먹을 수 있는 물고기 중 가장 가까운 물고기를 잡아먹은 후, 처음 위치로부터의 거리와 그 물고기를 잡아먹은 후 상어의 좌표를 반환하는 `bfs(row, col)` 함수를 정의한다.  
BFS 탐색에서는 현재의 경로가 항상 최적이라는 점을 이용한다. 다시 말해, 탐색 중 물고기를 한 번이라도 만나면 그 경로는 그 물고기까지의 최단경로가 된다. 반복 중 현재의 거리 최솟값보다 더 큰 경우는 조사할 필요가 없고(큐에 삽입할 필요 X), 최단거리가 동일한 물고기가 2마리 이상이라면 `row`값이 작은 물고기를, 거리와 `row`값이 동일하다면 `col`값도 비교하여 제일 작은 물고기를 선택하여 먹게 된다.  
  
`bfs()` 함수가 정의되었다면 남아있는 물고기가 존재하지 않을 때 까지 루프를 돌면서 `bfs()`를 반복 호출하여 물고기를 잡아먹음과 동시에 상어의 위치를 계속 이동시키고, 문제의 조건에 맞게 자신의 크기와 동일한 수의 물고기를 잡아먹었다면 상어의 크기를 1 성장시킨다.  
루프 안에서 한 번 상어가 위치했던 곳은 이미 물고기가 잡아먹혔으므로, 루프를 돌면서 원본 `matrix` 배열에서 해당 좌표를 0으로 바꿔 주어야 한다.  
루프는 `bfs()`가 `False`를 반환한 경우(남아있는 물고기가 있지만 더 이상 잡아먹을 수 있는 물고기가 없을 경우) 또는 `fish_cnt`가 0이 되는 경우(더 이상 남아 있는 물고기가 없는 경우) 탈출하고, 그때 누적된 시간을 출력하면 된다.


## ❗ 추가 지식
C언어에서 `INT_MAX` 매크로를 무한대를 정의하는 값으로 사용하는 것과 유사하게, `int(1e9)`를 사용하여 무한대를 표현할 수 있다.  
`sort()` 함수로 정렬할 때, 정렬할 키 들의 우선순위 규칙이 간단한 경우에는 굳이 람다식을 사용하여 키 함수를 인자에 전달해 주지 않고, 단순히 우선순위 순으로 데이터를 배치하여 (이번 문제에서는 `(dist, row, col)`) 간단하게 사용할 수 있다.


## 🙂 마무리
상어의 좌표를 따로 저장해 두었다가 그 좌표값을 사용하여 bfs를 반복한다는 것 까지만 생각을 해 내고 그 뒤로는 감이 안 잡혀서 풀이를 참고했다. 풀이를 하나하나 공부할 때는 이해가 안 가는 부분은 없었지만, 내가 이런 생각을 실제로 할 수 있을지는 아직까지는 미지수. 그래프 탐색은 DP 문제들과 다르게 끝까지 직접 해 보기가 까다로운 부분이 많아서 생각하기 더 어려운 것 같기도 하다.

