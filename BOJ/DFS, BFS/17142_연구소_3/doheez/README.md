## Info

<a href="https://www.acmicpc.net/problem/17142" rel="nofollow">17142번: 연구소 3</a>

## ❗ 풀이
1. 입력 받을 때 미리 저장해둔 바이러스 위치 중 M개를 겹치지 않게 고른다. M개를 모두 고를 때까지 반복문 안에서 재귀를 돌리는데, 재귀함수 내부에서의 반복문 시작 `index`는 재귀함수를 호출한 함수에서 고른 `index`보다 1만큼 높게 설정해서 겹치지 않게 만든다.
2. M개를 모두 고를 때마다 bfs로 바이러스를 확산시킨다. 이때, M개의 활성 바이러스 위치를 큐에 먼저 담은 후 `visit` 배열에 1로 표시해놓고 반복문을 돌린다.
    1. 방문하지 않은 노드를 방문할 때 빈칸과 비활성 바이러스 모두 시간을 1만큼 증가시켜줘야 하며, 개수는 빈칸만 세어준다.
    2. 빈칸 개수가 입력 받을 때 셌던 것과 같아지면 바이러스가 모두 확산되었다는 뜻이므로 시간을 최솟값과 비교해서 저장한 후 bfs를 종료한다.
3. 처음부터 빈칸이 존재하지 않거나, 전체 노드에 바이러스 확산이 불가능한 경우는 메인 함수에서 따로 체크해준다.

## ❗ 추가 지식
이차원 배열의 여러 부분에서 시간이나 개수가 동시에 증가하며 퍼져나가는 문제는 bfs할 때 `while`문을 중첩해서 구현하는 것이 더 깔끔하다.

바깥쪽 `while`문에서는 큐가 비었는지 여부를 체크하고 큐의 길이를 변수 `x`에 저장한다. 안쪽 `while`문은 `x == 0`일 때까지 돌리면서 bfs 탐색을 하는 것이다. 그러면 안쪽 `while`문을 탈출할 때 바깥쪽 `while`문 시작 시 큐에 들어있던 모든 노드에서 특정 시간이 동일하게 흐른 효과가 생긴다.

이 문제는 `while`문을 한 번만 사용해서 풀었지만, 다음 bfs 문제는 위와 같은 방법을 적용해봐야겠다.

## 🙂 마무리
이번에도 `visited` 배열 초기화가 관건이었다. M개의 바이러스를 활성화시킨 `visited` 배열을 bfs할 때 그대로 가져다 쓰고서 return 시 원래대로 되돌려주지 않아서 다음 bfs 시행에서 문제가 생겼다.

그래서 bfs를 시작할 때 `visited`를 복사한 `visit` 배열을 따로 만들어 쓰면서 문제를 해결했다.